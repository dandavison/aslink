#+startup: hideblocks

* Introduction
  The output from the Solexa pipeline is a file containing
  around 5 x 10^6 sequence reads, each about 20-80 bp long. These
  correspond to multiple genomic loci in multiple individuals. A given
  locus in a given individual may have many different reads. Thus
  variation between the different sequences is due to
  1. Non-homology of sequences
  2. Polymorphism
  3. Sequencing error

  The task is to cluster the 5 million sequences so that all members
  of a given cluster represent the same locus, and so that no
  sequences representing the same locus are members of different
  clusters.

  There is one sequence read per line; the top of the file looks like
  this

#+begin_example 
yakuba:/data/shared/Hpy_parsed_as_Nde> h combined
CAAATACCAATTTTGCATGATCAATGCTTGCTTGATTTTATATCAATATGTTTATGCTTATATTTCAT
AAGGTGCAGAAAACTTTTTGGTTTAAAACCAAAAATTTTTCTATAATCATACA
TTAAACAATGCCTGCACCACACCAATTAAATAAAAAAGTGCTATTCTTATTTAAAACTCCTGTGTATA
TTCACCCCTCTTGATAGGTAATGTTTTATTGCTAATTACATGCATACA
GTGATGAATGTGTCAAAGAGAATGGCAAAAGTCTCCTGTTAGTATGNTTGAAAAAAGATCTTGATGTG
TGAACCTTGAGGAACCCCGGAAGTAACAACATACC
CGGCCTTGTCATCCTGAGTTCGATTGGTCCGGACAAGAGTAAACACGTGATGGATTACGACATACAAC
TAACAAATGTATCAATCATAAATGATTTTTGTGTGTTTAATTAACATACCTGGATCGGAGAGAGGTTC
TCATGGAGTTTTAAAATCTTATCTTAAAGTTATAGAAATTAAAAAAACACTGTGTATGAGTAGTGTAA
CAACTCGTTCAAGTCAAATCACTGTTATCAATTTACATCACTGCAAACATCCAACGCCATTAAAATAG
#+end_example

* Simple clustering in C
*** Algorithm
  The C code implements the following algorithm:
  
#+begin_src python -n
  for each sequence i:
      if sequence i has been seen before:
          assign i to same cluster as before
      else:
          for each existing cluster k:
              d = distance(sequence i, canonical sequence k)
              if d <= d_max:
                  if i not yet assigned: assign i to cluster k
                  merge cluster k with cluster containing i
              else if d <= 2 * d_max:
                  for each sequence j in cluster k:
                      if dist(i, j) <= d_max:
                          if i not yet assigned: assign i to k
                          merge cluster k with cluster containing i
                          skip to next k
          if i not yet assigned:
              assign i to new cluster
#+end_src
		  
*** C code
#+begin_src C :tangle quickclust.c
  #include <stdlib.h>
  #include <stdio.h>
  #include <assert.h>
  #include <unistd.h>
  #include <stdarg.h>
  
  #define NSTATES 5
  #define NODE_STACK_SIZE 100000
  #define GROWFAC 4                  /* Growth multiple when reallocing arrays */
  #define false 0
  #define true 1
  typedef int bool ;
  enum {NA = -1} ;
  struct node {
      int cluster ;
      struct node *d[NSTATES] ;
  } ;
  struct node *newNode(int n) ;
  
  void free_tree(struct node *v) ;
  void encode(char *seq, int seqlen, int *iseq) ;
  void usage() ;
  void error(char *fmt, ...) ;
  void *memcpy(void *dest, const void *src, size_t n);
  ssize_t getline(char **lineptr, size_t *n, FILE *stream);
  
  void make_new_cluster(char *seq) ;
  void add_to_cluster(char *seq, int k) ;
  void merge_clusters(int source, int sink) ;
  void realloc_cluster_arrays() ;
  void malloc_arrays() ;
  
  /* Globals */
  int K ;
  int maxclusts = 1 ;                 /* current number of allocated clusters */
  int maxseqs = 1 ;              /* current number of allocated sequences */
  int seqlen=-1 ;
  int *clustermaxseqs ;
  
  char ***sequence ;             /* sequence[k][j] is unique sequence j in cluster k */
  char *canonical_member ;
  int *cluster, *map, *size ;
  int *iseq ;                    /* integer-encoded sequence */           
  
  
  int main(int argc, char **argv) {
      char *seq=NULL ;              /* getline automatically mallocs and reallocs seq */
      size_t maxlinelength=0 ;       /* and increments maxlinelength. */
      char *canon ;
      bool gotit, verbose=false ;
      struct node
          *root = newNode(1), *v,
          *nodestack = newNode(NODE_STACK_SIZE),
          *nodestack_end = nodestack + NODE_STACK_SIZE ;
      int i, c, ic, j, d, n, k, dmax=-1, numseqs ;
  
      while((c = getopt(argc, argv, "c:d:v")) != -1) {
          switch(c) {
          case 'c': seqlen = atoi(optarg) ; break ;
          case 'd': dmax = atoi(optarg) ; break ;
          case 'v': verbose = true ; break ;
          case '?': usage() ;
          }
      }
      if(seqlen <= 0 || dmax < 0) usage() ;
      malloc_arrays() ;
  
      i = K = 0 ;
      while( (n = getline(&seq, &maxlinelength, stdin)) > 0 ) {
          if( --n < seqlen )
              error("Seq %d has %d characters (should be at least %d)\n", i+1, n, seqlen) ;
          
          /* First, check if identical sequence has been seen before. */
          encode(seq, seqlen, iseq) ;
          for(v = root, c = 0 ; c < seqlen ; c++) {
              ic = iseq[c] ;
              if(v->d[ic] == NULL) {
                  if(nodestack == nodestack_end) {
                      nodestack = newNode(NODE_STACK_SIZE) ;
                      nodestack_end = nodestack + NODE_STACK_SIZE ;
                  }
                  v->d[ic] = nodestack++ ;
              }
              v = v->d[ic] ;
          }
          cluster[i] = v->cluster ;
          if( cluster[i] == NA ) {
              /* Sequence not seen before; compare with canonical sequences. */
              gotit = false ;
              for(canon = canonical_member, k = 0 ; k < K ; k++, canon += seqlen) {
                  for(d = 0, c = 0 ; c < seqlen ; c++) if(seq[c] != canon[c]) d++ ;
                  if(d <= dmax ) {
                      if(!gotit) {
                          cluster[i] = v->cluster = k ;
                          add_to_cluster(seq, k) ;
                          gotit = true ;
                      }
                      /* Now, all the clusters that were equivalent to k
                         (i.e. map[k]), must be made equivalent to cluster[i] */
                      merge_clusters(map[k], cluster[i]) ;
                      if(verbose) fprintf(stderr, "%d: close to canonical sequence (%d) \n", i+1, k+1) ;
                  }
                  else if( d <= 2*dmax ) {
                      /* Check whether sequence is close to one of the cluster members */
                      for(j = 0 ; j < size[k] ; ++j) {
                          for(d = 0, c = 0 ; c < seqlen ; c++) if(seq[c] != sequence[k][j][c]) d++ ;
                          if( d <= dmax ) {
                              if(!gotit) {
                                  cluster[i] = v->cluster = k ;
                                  add_to_cluster(seq, k) ;
                                  memcpy(sequence[k][size[k]], seq, seqlen * sizeof(char)) ;
                                  gotit = true ;
                              }
                              /* Now, all the clusters that were equivalent to k
                                 (i.e. map[k]), must be made equivalent to cluster[i] */
                              merge_clusters(map[k], cluster[i]) ;
                              if(verbose)
                                  fprintf(stderr, "%d: close to non-canonical sequence %d of cluster (%d)\n", i+1, j+1, k+1) ;
                              break ;                             /* No need to check other cluster members */
                          }
                      }
                  }
              }
              if(cluster[i] == NA) {
                  /* Not seen before and not close to any member of any existing cluster. */
                  cluster[i] = v->cluster = map[K] = K ;
                  if(verbose) fprintf(stderr, "%d: new cluster (%d)\n", i+1, cluster[i]+1) ;
                  make_new_cluster(seq) ;
              }
          }
          else if(verbose) fprintf(stderr, "%d: seen before (cluster %d)\n", i+1, cluster[i]+1) ;
          if(i % 10000 == 0 && i > 0) fprintf(stderr, "%6d\r", i) ;
          if(++i == maxseqs) {
              maxseqs *= GROWFAC ;
              cluster = realloc(cluster, maxseqs * sizeof(int)) ;
          }
      }
   
      for(numseqs = i, i = 0 ; i < numseqs ; ++i)
          printf("%d\n", map[cluster[i]] + 1) ;
  
      free(canonical_member) ;
      free(iseq) ;
      free(cluster) ;
      free(map) ;
      return 0 ;
  }
  
  void merge_clusters(int source, int sink) {
      int k ;
      for(k = 0 ; k < K ; k++)
          if(map[k] == source) map[k] = sink ;
  }
  
  void make_new_cluster(char *seq) {
      memcpy(canonical_member + K * seqlen, seq, seqlen * sizeof(char)) ;
      add_to_cluster(seq, K) ;
      if(++K == maxclusts) realloc_cluster_arrays() ;
  }
  
  void add_to_cluster(char *seq, int k) {
      int j, clustermaxseqs_k_old ;
      memcpy(sequence[k][size[k]], seq, seqlen * sizeof(char)) ;
      if( ++size[k] == clustermaxseqs[k] ) {
          clustermaxseqs_k_old = clustermaxseqs[k] ;
          clustermaxseqs[k] *= GROWFAC ;
          sequence[k] = realloc(sequence[k], clustermaxseqs[k] * sizeof(char *)) ;
          for(j = clustermaxseqs_k_old ; j < clustermaxseqs[k] ; ++j)
              sequence[k][j] = (char *) malloc(seqlen * sizeof(char)) ;
      }
  }
  
  void realloc_cluster_arrays() {
      int j, k, maxclusts_old ;
  
      maxclusts_old = maxclusts ;
      maxclusts *= GROWFAC ;
      canonical_member = realloc(canonical_member, maxclusts * seqlen * sizeof(char)) ;
      map = realloc(map, maxclusts * sizeof(int)) ;
      size = realloc(size, maxclusts * sizeof(int)) ;
  
      clustermaxseqs = realloc(clustermaxseqs, maxclusts * sizeof(int)) ;
      sequence = realloc(sequence, maxclusts * sizeof(char **)) ;
      for(k = maxclusts_old ; k < maxclusts ; ++k) {
          clustermaxseqs[k] = 1 ;
          sequence[k] = (char **) malloc(clustermaxseqs[k] * sizeof(char *)) ;
          for(j = 0 ; j < clustermaxseqs[k] ; ++j)
              sequence[k][j] = (char *) malloc(seqlen * sizeof(char)) ;
      }
  }
  
  
  void malloc_arrays() {
      int j, k ;
  
      iseq = (int *) malloc(seqlen * sizeof(int)) ;
      cluster = (int *) malloc(maxseqs * sizeof(int)) ;
      canonical_member  = (char *) malloc(maxclusts * seqlen * sizeof(char)) ;
      map = (int *) malloc(maxclusts * sizeof(int)) ;
      size = (int *) calloc(maxclusts, sizeof(int)) ;
  
      clustermaxseqs = (int *) malloc(maxclusts * sizeof(int)) ;
      sequence = (char ***) malloc(maxclusts * sizeof(char **)) ;
      for(k = 0 ; k < maxclusts ; ++k) {
          clustermaxseqs[k] = 1 ;
          sequence[k] = (char **) malloc(clustermaxseqs[k] * sizeof(char *)) ;
          for(j = 0 ; j < clustermaxseqs[k] ; ++j)
              sequence[k][j] = (char *) malloc(seqlen * sizeof(char)) ;
      }
  }    
  
  
  void encode(char *seq, int seqlen, int *iseq) {
      int i ;
      char c ;
      for(i = 0 ; i < seqlen ; i++) {
          c = seq[i] ;
          iseq[i] = 
              c == 'A' ? 0 :
              c == 'C' ? 1 :
              c == 'G' ? 2 :
              c == 'T' ? 3 :
              c == 'N' ? 4 :
              NA ;
          if(iseq[i] == NA)
              error("Invalid base: %c\n", c) ;
      }
  }
  
  struct node *newNode(int n) {
      int i ; 
      struct node *v, *new = (struct node *) malloc(n * sizeof(struct node)) ;
      
      for(v = new ; v < new + n ; v++) {
          for(i = 0 ; i < NSTATES ; i++) v->d[i] = NULL ;
          v->cluster = NA ;
      }
      return new ;
  }
  
  void free_tree(struct node *v) {
      int i ;
      for(i = 0 ; i < NSTATES ; i++) {
          if(v->d[i] != NULL) {
              free_tree(v->d[i]) ;
              free(v->d[i]) ;
          }
      }
  }
  
  void error(char *fmt, ...) {
      va_list args;
  
      fflush(stderr);
      
      va_start(args, fmt);
      vfprintf(stderr, fmt, args);
      va_end(args);
      
      fflush(stderr) ;
      exit(2) ;
  }
  
  void usage() {
      error("quickclust -c numchars -d maxdiff") ;
  }
#+end_src
  
*** Makefile
#+begin_src makefile :tangle makefile
  CFLAGS = -O2 -Wall
  all:    quickclust
#+end_src
*** Timing
| code                             |    seqs |  c | d | clusters found | outfile        |      time |
|----------------------------------+---------+----+---+----------------+----------------+-----------|
| vanilla                          |     1e4 | 20 | 5 |           4439 | clusters-0-1e4 |     0.435 |
| vanilla                          |     1e5 | 20 | 5 |          12070 | clusters-0-1e5 |       7.4 |
| check seqlen & progress          |     1e5 | 20 | 5 |          12070 |                |       7.6 |
| check seqlen progress every 1000 |         |    |   |                |                |       7.3 |
|                                  | 5288915 |    |   |          69655 |                | ~ 10 mins |
| tree-based lookup                | 5288915 |    |   |          69655 |                | 95 secs   |
*** Results
***** Complete
#+begin_src R 
  g1 <- scan("clusters-all-c20-d4-complete", what=integer())
  g2 <- scan("clusters-all-c20-d4-complete-rev", what=integer())
  tg1 <- table(g1)
  tg2 <- table(g2)
  ttg1 <- table(tg1)
  ttg2 <- table(tg2)
#+end_src
***** Merged
#+begin_example
> g <- scan("/home/dan/pa/Papilio/clusters-all-c20-d4-merge", what=integer())
Read 5288915 items
> tg <- table(g)
> length(tg)
[1] 64153
> sum(tg > 1)
[1] 49358
> sum(tg > 1000)
[1] 1353
> ttg <- table(tg)
> ttg[1:20]
tg
    1     2     3     4     5     6     7     8     9    10    11    12    13 
14795 11200  8081  5571  3875  2706  1770  1296   915   675   468   364   290 
   14    15    16    17    18    19    20 
  220   174   167   133   131    96   104 
#+end_example
* Validation
***** R implementation of same clustering procedure
#+begin_src R 
  library(RColorBrewer, lib="~/lib/R")
  library(TraMineR, lib="~/lib/R")
  
  ## file <- "/data/shared/Hpy_parsed_as_Nde/combined"
  ## x <- read.sequences(pipe(sprintf("head -n 10000 < %s", file)))
  get.dist <- function(file, c) {
      x <- read.sequences(file)
      x <- x[,1:c]
      sx <- seqdef(x)
      seqdist(sx, method="HAM", with.miss=TRUE, full.matrix=FALSE)
  }
  
  cluster <- function(dx, d) {
      n <- attr(dx, "Size")
      clusters <- rep(NA, n)
      k <- 1
      for(i in 1:n) {
          if(i %% 10 == 0) cat(i, "\r")
          close <- dx[i,] <= d
          close.clusters <- clusters[close]
          close.clusters <- close.clusters[!is.na(close.clusters)]
          if(length(close.clusters) > 0) {
              oldk <- min(close.clusters)
              clusters[close] <- oldk
          }
          else {
              clusters[close] <- k
              k <- k+1
          }
      }
      cat("\n")
      clusters
  }
  
  cluster.C <- function(file, c, d)
      scan(pipe(sprintf("quickclust -c %d -d %d < %s", c, d, file)), what=integer())
  
  
  check <- function(file, c, d) {
      dx <- get.dist(file, c)
      R <- cluster(dx, d)
      C <- cluster.C(file, c, d)
      print(table(R == C))
      print(table(table(R) == table(C)))
      cbind(R=R, C=C)
  }
  
  relabel <- function(z)
      as.integer(factor(z, levels=sort(unique(z))))
#+end_src
*** Check arity
#+begin_src R
  check.arity <- function(x, z, d, arity=1, file, quiet=TRUE) {
      if(!quiet && !missing(file)) {
          file <- file(file)
          sink(file)
      }
      n <- length(z)
      ans <- matrix(NA, nrow=n, ncol=2, dimnames=list(NULL, c("C","R")))
      
      tz <- table(z)
      for(i in seq_along(z)) {
          k <- z[i]
          count.quickclust <- sum(z == k)
          if(!missing(arity) && count.quickclust != arity) next
          if(!quiet) {
              cat(i, "\t", k, "\t")
              cat(count.quickclust, "\t")
          }
          count.agrep <- length(agrep(x[i], x, max.distance=list(insert=0,del=0,all=d)))
          if(!quiet) {
              cat(count.agrep, "\n")
              if(!missing(file)) flush(file)
          }
          ans[i,] <- c(count.quickclust, count.agrep)
          if(i %% 100 == 0) cat(i, "\r", sep="")
      }
      cat("\n")
      ans
  }
  
  ## stopifnot(sum(x == x[which(g1 == as.integer(names(tg1)[max(which(tg1 == 1))]))]) == 1)
  
  check.singletons <- function(x, z, rev=FALSE) {
      printout <- 10
      tz <- table(z)
      ston.clusters <- as.integer(names(tz)[which(tz == 1)])
      ## in.ston <- z %in% ston.clusters
      ## sapply(stons, function(i) sum(x == x[which(z1 == i)]))
      ux <- unique(x)
      if(rev) ston.clusters <- rev(ston.clusters)
      i <- 1
      for(k in ston.clusters) {
          in.cluster <- z == k
          stopifnot(sum(in.cluster) == 1)
          seq <- x[in.cluster]
          arity <- length(agrep(seq, ux, max.distance=list(insert=0,del=0,all=1)))
          if(arity != 1)
              stop("Agrep finds", arity, "close sequences to supposedly singleton sequence", which(in.cluster))
          if((i <- i+1) %% printout == 0) cat(i, "\r", sep="")
      }
      if(i >= printout) cat("\n")
  }
#+end_src
*** Compare results with reversed input
#+begin_src sh
tac ../combined > combined-reversed
quickclust -c 20 -d 4 < combined-reversed | tac > clusters-all-c20-d4-rev
#+end_src

***** This may be confused
#+begin_src R
  file <- "/data/shared/Hpy_parsed_as_Nde/combined"
  x <- read.seqs.2(file, 20) 
  ux <- unique(x)
  
  g <- scan("clusters-all-c20-d4-merge", what=integer())
  
  tg <- table(g)
  singlei <- as.integer(names(tg[tg == 1]))
  
  k <- max(singlei)
  ink <- which(g == k)
  stopifnot(length(ink) == 1)
  xi <- x[ink]
  
  close <- agrep(xi, ux, useBytes=TRUE, max.distance=4)
#+end_src
* Read sequences into R
#+begin_src R :session *shell*
  read.sequences <- function(file) {
      cat(date(), "\tReading sequences")
      x <- scan(file, what="", quiet=TRUE)
      x <- strsplit(x, "")
      
      cat("\n")
      
      lengths <- sapply(x, length)
      min.length <- min(lengths)
      cat(date(), "\tDiscarding all but initial", min.length, "bases")
      x <- lapply(x, "[", 1:min.length)
      cat("\n")
      
      cat(date(), "\tConverting to matrix format (each column is one sequence)")
      ## x <- matrix(as.integer(unlist(x)), ncol=nseqs, nrow=min.length)
      x <- matrix(unlist(x), nrow=length(x), ncol=min.length, byrow=TRUE)
      cat("\n")
      
      x
  }
  
  read.seqs.2 <- function(file, nchar)
      scan(pipe(sprintf("cut -c1-%d < %s", nchar, file)), what="")
#+end_src

* Split input into clusters
*** lines
#+begin_src R
  write.lines <- function(i) {
      if(i %% 100 == 0) cat(i, "\r")
      cat(which(clusters == i), sep="\n", file=file.path("lines", sprintf("%05d.lines", i)))
  }
  lapply(unique(clusters), write.lines)
#+end_src

*** R
#+begin_src R 
  file <- "/data/shared/Hpy_parsed_as_Nde/combined"
  x <- scan(file, what="", quiet=TRUE)
  split.sequences <- function(x, clusters) {
      for(i in unique(clusters)) {
          if(i %% 100 == 0) cat(i, "\r")
          cat(x[clusters == i], sep="\n", file=file.path("clusters", sprintf("%05d", i)))
      }
      cat("\n")
  }
#+end_src
*** sed
    This is too slow
#+begin_src sh
  #!/bin/bash
  mkdir -p clusters
  i=1
  combined=/data/shared/Hpy_parsed_as_Nde/combined
  while read cluster ; do
      sed -n ${i}p < $combined >> clusters/$cluster
      echo $i
      (( i += 1 ))
  done
#+end_src

* An incomplete attempt in R
    The idea here was to use various sorting heuristics, eliminate
    duplicate sequences that occur consecutively in the sorted output,
    and thus end up with a manageable number of sequences to cluster.

    I was considering forming the lower-triangle of the full distance
    matrix using dist(), and then applying a hierarchical clustering
    method using hclust() and identifying clusters at some similarity
    threshold using cutree(). But I am concerned that dist/hclust will
    be hopelessly slow, and decided to investigate straightforward
    solutions in C first.

#+begin_src R
  cluster.sequences <- function(file, thresh) {
      nseqs <- as.integer(system(paste("wc -l <", file), intern=TRUE))
      ans <- rep(NA, nseqs)
  
      ## file <- pipe(sprintf("tr 'AGCT' '1234' < %s", file))
  
      x <- read.sequences(file)
      nas <- rep(NA, nrow(x))
      distances <- function(x) {
          ax <- cbind(nas, x)
          bx <- cbind(x, nas)
          d <- abs(colSums(ax - bx)) / min.length
          d[-c(1,ncol(ax))]
      }
      
      cat(date(), "\tComputing distances between consecutive sequences")
      close <- rle(distances(x) < thresh)
      
      cat("\n")
  
      
      close
  }
#+end_src
