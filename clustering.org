#+startup: hideblocks

* Introduction
  The output from the Solexa pipeline is a file containing
  around 5 x 10^6 sequence reads, each about 20-80 bp long. These
  correspond to multiple genomic loci in multiple individuals. A given
  locus in a given individual may have many different reads. Thus
  variation between the different sequences is due to
  1. Non-homology of sequences
  2. Polymorphism
  3. Sequencing error

  The task is to cluster the 5 million sequences so that all members
  of a given cluster represent the same locus, and so that no
  sequences representing the same locus are members of different
  clusters.

  There is one sequence read per line; the top of the file looks like
  this

#+begin_example 
yakuba:/data/shared/Hpy_parsed_as_Nde> h combined
CAAATACCAATTTTGCATGATCAATGCTTGCTTGATTTTATATCAATATGTTTATGCTTATATTTCAT
AAGGTGCAGAAAACTTTTTGGTTTAAAACCAAAAATTTTTCTATAATCATACA
TTAAACAATGCCTGCACCACACCAATTAAATAAAAAAGTGCTATTCTTATTTAAAACTCCTGTGTATA
TTCACCCCTCTTGATAGGTAATGTTTTATTGCTAATTACATGCATACA
GTGATGAATGTGTCAAAGAGAATGGCAAAAGTCTCCTGTTAGTATGNTTGAAAAAAGATCTTGATGTG
TGAACCTTGAGGAACCCCGGAAGTAACAACATACC
CGGCCTTGTCATCCTGAGTTCGATTGGTCCGGACAAGAGTAAACACGTGATGGATTACGACATACAAC
TAACAAATGTATCAATCATAAATGATTTTTGTGTGTTTAATTAACATACCTGGATCGGAGAGAGGTTC
TCATGGAGTTTTAAAATCTTATCTTAAAGTTATAGAAATTAAAAAAACACTGTGTATGAGTAGTGTAA
CAACTCGTTCAAGTCAAATCACTGTTATCAATTTACATCACTGCAAACATCCAACGCCATTAAAATAG
#+end_example

* Read sequences into R
#+begin_src R
  read.sequences <- function(file) {
      cat(date(), "\tReading sequences")
      x <- scan(file, what="", quiet=TRUE)
      x <- strsplit(x, "")
      cat("\n")
      
      lengths <- sapply(x, length)
      min.length <- min(lengths)
      cat(date(), "\tDiscarding all but initial", min.length, "bases")
      x <- lapply(x, "[", 1:min.length)
      cat("\n")
      
      cat(date(), "\tConverting to matrix format (each column is one sequence)")
      ## x <- matrix(as.integer(unlist(x)), ncol=nseqs, nrow=min.length)
      x <- matrix(unlist(x), nrow=length(x), ncol=min.length, byrow=TRUE)
      cat("\n")
      
      x
  }
#+end_src


#+begin_src R 
  library(RColorBrewer, lib="~/lib/R")
  library(TraMineR, lib="~/lib/R")
  
  file <- "/data/shared/Hpy_parsed_as_Nde/combined"
  x <- read.sequences(pipe(sprintf("head -n 10000 < %s", file)))
  x <- x[,1:20]
  sx <- seqdef(x)
  dx <- seqdist(sx, method="HAM", with.miss=TRUE, full.matrix=FALSE)
  summary(dx)
#+end_src

* Simple clustering in C
*** Algorithm
  This C code implements the following algorithm:
  
#+begin_src python
  for each sequence:
      for each canonical_sequence:
          if sequence is close to canonical sequence:
              assign sequence to that cluster
      if sequence is unassigned:
          make sequence canonical representative of new cluster
#+end_src
  
  In this algorithm, when we create a new cluster, we know that the
  canonical sequence is not "close" to any of the other canonical
  sequences.

  *However* it is possible that
  1. A new canonical sequence is "close" to an assigned non-canonical
     sequence.
  2. A newly assigned sequence is similar to sequences in other
     clusters (either canonical or non-canonical).

  So the algorithm is not correct in general. But it should work well
  when different loci have very different sequences.

*** C code
#+begin_src C :tangle quickclust.c
  #include <stdlib.h>
  #include <stdio.h>
  #include <assert.h>
  #include <unistd.h>
  #include <stdarg.h>
  
  #define NSTATES 5
  #define NODE_STACK_SIZE 100000
  
  enum {NA = -1} ;
  struct node {
      int cluster ;
      struct node *d[NSTATES] ;
  } ;
  struct node *newNode(int n) ;
  void free_tree(struct node *v) ;
  void encode(char *seq, int seqlen, int *iseq) ;
  void usage() ;
  void ERROR(char *fmt, ...) ;
  void *memcpy(void *dest, const void *src, size_t n);
  ssize_t getline(char **lineptr, size_t *n, FILE *stream);
  
  int main(int argc, char **argv) {
      char *line=NULL ;           /* getline automatically mallocs and reallocs line */
      size_t maxlinelength=0 ;      /*    and increments maxlinelength */
      int *iseq ;              /* integer-encoded sequence */           
      int maxK = 1 ;                /* number of allocated canonical sequences */
      int i, c, ic, d, n, k, K, seqlen=-1, maxd=-1 ;
      int cluster ;
      char *canonical_member ;
      struct node
          *root = newNode(1), *v,
          *nodestack = newNode(NODE_STACK_SIZE),
          *nodestack_end = nodestack + NODE_STACK_SIZE ;
  
      while((c = getopt(argc, argv, "c:d:")) != -1) {
          switch(c) {
          case 'c': seqlen = atoi(optarg) ; break ;
          case 'd': maxd = atoi(optarg) ; break ;
          case '?': usage() ;
          }
      }
      if(seqlen <= 0 || maxd < 0) usage() ;
      iseq = (int *) malloc(seqlen * sizeof(int)) ;
      canonical_member  = (char *) malloc(maxK * seqlen * sizeof(char)) ;
  
      i = K = 0 ;
      while( (n = getline(&line, &maxlinelength, stdin)) > 0 ) {
          if( --n < seqlen )
              ERROR("Line %d has %d characters (should be at least %d)\n", i, n, seqlen) ;
          encode(line, seqlen, iseq) ;
          
          /* First, check if identical sequence has been seen before. */
          for(v = root, c = 0 ; c < seqlen ; c++) {
              ic = iseq[c] ;
              if(v->d[ic] == NULL) {
                  if(nodestack == nodestack_end) {
                      nodestack = newNode(NODE_STACK_SIZE) ;
                      nodestack_end = nodestack + NODE_STACK_SIZE ;
                  }
                  v->d[ic] = nodestack++ ;
              }
              v = v->d[ic] ;
          }
          if( (cluster = v->cluster) == NA ) {
              /* Sequence not seen before; compare with canonical sequences. */
              for(k = 0 ; k < K ; k++) {
                  for(d = 0, c = 0 ; c < seqlen ; c++)
                      if(line[c] != canonical_member[k * seqlen + c]) d++ ;
                  if( d <= maxd ) { cluster = v->cluster = k ; break ; }
              }
              if(cluster == NA) {
                  /* Not seen before and not similar to any canonical member. */
                  cluster = v->cluster = K ;
                  memcpy(canonical_member + K * seqlen, line, seqlen * sizeof(char)) ;
                  if(++K == maxK) {
                      maxK *= 4 ;
                      canonical_member = realloc(canonical_member, (size_t) (maxK * seqlen * sizeof(char))) ;
                  }
              }
          }
          printf("%d\n", cluster + 1) ;
          if(i % 10000 == 0 && i > 0) fprintf(stderr, "%6d\r", i) ;
          i++ ;
      }
      free(canonical_member) ;
      free(iseq) ;
      return 0 ;
  }
  
  void encode(char *seq, int seqlen, int *iseq) {
      int i ;
      char c ;
      for(i = 0 ; i < seqlen ; i++) {
          c = seq[i] ;
          iseq[i] = 
              c == 'A' ? 0 :
              c == 'C' ? 1 :
              c == 'G' ? 2 :
              c == 'T' ? 3 :
              c == 'N' ? 4 :
              NA ;
          if(iseq[i] == NA)
              ERROR("Invalid base: %c\n", c) ;
      }
  }
  
  struct node *newNode(int n) {
      int i ; 
      struct node *v, *new = (struct node *) malloc(n * sizeof(struct node)) ;
      
      for(v = new ; v < new + n ; v++) {
          for(i = 0 ; i < NSTATES ; i++) v->d[i] = NULL ;
          v->cluster = NA ;
      }
      return new ;
  }
  
  void free_tree(struct node *v) {
      int i ;
      for(i = 0 ; i < NSTATES ; i++) {
          if(v->d[i] != NULL) {
              free_tree(v->d[i]) ;
              free(v->d[i]) ;
          }
      }
  }
  
  void ERROR(char *fmt, ...) {
      va_list args;
  
      fflush(stderr);
      
      va_start(args, fmt);
      vfprintf(stderr, fmt, args);
      va_end(args);
      
      fflush(stderr) ;
      exit(2) ;
  }
  
  void usage() {
      ERROR("quickclust -c numchars -d maxdiff") ;
  }
#+end_src

*** Makefile
#+begin_src makefile :tangle makefile
  CFLAGS = -O2 -Wall
  all:    quickclust
#+end_src
*** Timing
| code                             |    seqs |  c | d | clusters found | outfile        |      time |
|----------------------------------+---------+----+---+----------------+----------------+-----------|
| vanilla                          |     1e4 | 20 | 5 |           4439 | clusters-0-1e4 |     0.435 |
| vanilla                          |     1e5 | 20 | 5 |          12070 | clusters-0-1e5 |       7.4 |
| check seqlen & progress          |     1e5 | 20 | 5 |          12070 |                |       7.6 |
| check seqlen progress every 1000 |         |    |   |                |                |       7.3 |
|                                  | 5288915 |    |   |          69655 |                | ~ 10 mins |
*** Validation
***** Compare results with reversed input

#+begin_src sh
tac ../combined > combined-reversed
quickclust -c 20 -d 4 < combined-reversed | tac > clusters-all-c20-d4-rev
#+end_src

* Split input into clusters
*** R
#+begin_src R 
  file <- "/data/shared/Hpy_parsed_as_Nde/combined"
  x <- scan(file, what="", quiet=TRUE)
  split.sequences <- function(x, clusters) {
      for(i in unique(clusters)) {
          if(i %% 100 == 0) cat(i, "\r")
          cat(x[clusters == i], sep="\n", file=file.path("clusters", sprintf("%05d", i)))
      }
      cat("\n")
  }
#+end_src
*** sed
    This is too slow
#+begin_src sh
  #!/bin/bash
  mkdir -p clusters
  i=1
  combined=/data/shared/Hpy_parsed_as_Nde/combined
  while read cluster ; do
      sed -n ${i}p < $combined >> clusters/$cluster
      echo $i
      (( i += 1 ))
  done
#+end_src

* An incomplete attempt in R
    The idea here was to use various sorting heuristics, eliminate
    duplicate sequences that occur consecutively in the sorted output,
    and thus end up with a manageable number of sequences to cluster.

    I was considering forming the lower-triangle of the full distance
    matrix using dist(), and then applying a hierarchical clustering
    method using hclust() and identifying clusters at some similarity
    threshold using cutree(). But I am concerned that dist/hclust will
    be hopelessly slow, and decided to investigate straightforward
    solutions in C first.

#+begin_src R
  cluster.sequences <- function(file, thresh) {
      nseqs <- as.integer(system(paste("wc -l <", file), intern=TRUE))
      ans <- rep(NA, nseqs)
  
      ## file <- pipe(sprintf("tr 'AGCT' '1234' < %s", file))
  
      x <- read.sequences(file)
      nas <- rep(NA, nrow(x))
      distances <- function(x) {
          ax <- cbind(nas, x)
          bx <- cbind(x, nas)
          d <- abs(colSums(ax - bx)) / min.length
          d[-c(1,ncol(ax))]
      }
      
      cat(date(), "\tComputing distances between consecutive sequences")
      close <- rle(distances(x) < thresh)
      
      cat("\n")
  
      
      close
  }
#+end_src
